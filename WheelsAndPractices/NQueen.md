# 回溯 DFS+剪枝解 N 皇后问题

## DFS 与回溯关系

- **DFS**：深度优先搜索，沿着一条路径深入探索到底，再回溯探索其他路径
- **回溯**：在 DFS 基础上，当发现当前路径不可能达到目标时，提前终止（剪枝）并回溯

## 关键剪枝策略

### (1) 列冲突剪枝

使用数组记录已被占用的列，快速判断当前位置是否可行

### (2) 对角线冲突剪枝

使用**数学性质**：在同一对角线上的点满足：

- **主对角线：行号 - 列号 = 常数**
- **副对角线：行号 + 列号 = 常数**

可以用两个数组分别记录已被占用的对角线

## 具体的设计

### board 数组

board 是一个一维数组，这是一个很巧妙的设计。在这个实现中：

1. board[i] 表示第 i 行的皇后放在第几列
2. 数组的下标 i 代表行号
3. 数组的值 board[i] 代表列号
   例如，对于 4 皇后的一个解：

```bash
- Q - -
- - - Q
Q - - -
- - Q -
```

它在一维数组中的表示是：

```C
board = [1, 3, 0, 2]
```

这样的表示方法有几个优点：

1. 自动保证了每行只有一个皇后（因为数组的每个位置只能存一个值）
2. 节省内存空间（一维数组比二维数组省空间）
3. 简化了列冲突的检查（直接比较值是否相等）
4. 简化了对角线冲突的检查（可以用行差和列差来判断）
   这比使用二维数组来表示棋盘要更加高效和简洁。

## 体会和感悟

### 关于 DFS 和回溯

用递归的函数栈来模拟 DFS 搜索过程，回溯时会自动回到上一层的状态，无需手动回溯  
某个状态空间被认定为不可行时，不再继续搜索，即剪枝，避免了不必要的搜索路径

### 关于 broad 数据结构的巧妙设计

天才方案！byd 人类怎么能整出这么天才的活，下标代表行号，值代表放置的列号，这辈子想不出来昂()
